import java.util.List;

/**
 * Interface defining methods necessary to implement Rabin-Karp and
 * Boyer-Moore.
 *
 * @author Kevin Simon
 */

public interface StringSearchInterface {

	/**
	 * Boyer Moore algorithm that relies on last table. Make sure to implement
	 * the table before implementing this method. Works better with large
	 * alphabets.
	 *
	 * @param needle a string you a searching for in a body of text
	 * @param haystack the body of text where you search for needle
	 * @return list of integers representing the first index a match occurs
	 */
	public List<Integer> boyerMoore(String needle, String haystack);

	/**
	 * Builds last table that can be used to run the Boyer Moore algorithm.
	 * The formula for computing a given entry of the last table is:
	 *
	 *		max(needle.length - needle.lastIndexOf(c) - 1, 1)
	 *
	 * where c is a particular character in your needle.
	 *
	 * HINT: Characters auto cast to their corresponding int in ASCII
	 *
	 * @param needle a string you are building last table for
	 * @return integer array of size (Character.MAX_VALUE + 1) containing the mapping
	 *		   for all characters in the alphabet
	 */
	public int[] buildLastTable(String needle);

	// prime base used for Rabin-Karp hashing, don't edit!!
	public static final int BASE = 433;

	/**
	 * Hash function used for Rabin-Karp. The formula for hashing a string is:
	 *
	 *		sum of: c * BASE ^ (needle.length - 1 - i), where c is the integer
	 *		value of the current character, and i is the index of the character
	 *
	 * For example: Hashing "bunn" as a substring of "bunny" with base 433 hash
	 * = b * 433 ^ 3 + u * 433 ^ 2 + n * 433 ^ 1 + n * 433 ^ 0 = 98 * 433 ^ 3 +
	 * 117 * 433 ^ 2 + 110 * 433 ^ 1 + 110 * 433 ^ 0 = 7977892179
	 *
	 * @param current substring you are generating hash function for
	 */
	 public int generateHash(String current);

	 /**
	  * Updates a hash in constant time to avoid constantly recalculating
	  * entire hash. To update the hash:
	  *
	  * 	remove the oldChar times BASE raised to the length -
	  * 	1, multiply by BASE, and add the newChar
	  *
	  * For example: Shifting from "bunn" to "unny" in "bunny" with base 433
	  * hash("unny") = (hash("bunn") - b * 433 ^ 3) * 433 + y * 433 ^ 0 =
	  * (7977892179 - 98 * 433 ^ 3) * 433 + 121 * 433 ^ 0 = 9519051770
	  *
	  * @param oldHash hash generated by generateHash
	  * @param length length of needle/substring of haystack
	  * @param oldChar character we want to remove from hashed substring
	  * @param newChar character we want to add to hashed substring
	  */
	  public int updateHash(int oldHash, int length, char oldChar,
	  							   char newChar);

	  /**
	   * Runs Rabin-Karp algorithm. Generate initial hash, and compare it with
	   * hash from substring of haystack same length as needle. If the two
	   * hashes match compare their individual characters, else update hash
	   * and continue.
	   *
	   * @param needle a string you a searching for in a body of text
	   * @param haystack the body of text where you search for needle
	   * @return list of integers representing the first index a match occurs
	   */
	  public List<Integer> rabinKarp(String needle, String haystack);
}